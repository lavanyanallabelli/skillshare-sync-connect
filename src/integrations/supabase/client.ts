
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://rojydqsndhoielitdquu.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJvanlkcXNuZGhvaWVsaXRkcXV1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ3NTM2MTgsImV4cCI6MjA2MDMyOTYxOH0.CPvCmtErCNAQ0mAbXBUAzShvI9eytI8Hi6tm_Z-66SQ";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      storageKey: 'supabase.auth.token',
    },
    // Improved configuration for realtime subscriptions
    realtime: {
      params: {
        eventsPerSecond: 10
      }
    }
  }
);

// Add a helper function to check Supabase connection
export const checkSupabaseConnection = async () => {
  try {
    const { data, error } = await supabase.from('notifications').select('count').limit(1);
    if (error) {
      console.error("Supabase connection error:", error);
      return false;
    }
    console.log("Supabase connection successful");
    return true;
  } catch (err) {
    console.error("Failed to check Supabase connection:", err);
    return false;
  }
};

// Helper function to create notifications for different events
export const createNotification = async (
  userId: string | null,
  type: string, 
  title: string, 
  description?: string, 
  actionUrl?: string
) => {
  if (!userId) return null;
  
  try {
    console.log(`[createNotification] Creating ${type} notification for user ${userId}`);
    
    const notification = {
      user_id: userId,
      type,
      title,
      description: description || '',
      action_url: actionUrl || '',
      read: false
    };
    
    const { data, error } = await supabase
      .from('notifications')
      .insert(notification)
      .select()
      .single();
      
    if (error) {
      console.error("[createNotification] Error:", error);
      return null;
    }
    
    console.log("[createNotification] Created successfully:", data);
    return data;
  } catch (err) {
    console.error("[createNotification] Exception:", err);
    return null;
  }
};

// Helper function to mark messages as read - Fixed to ensure read_at is properly set
export const markMessagesAsRead = async (
  receiverId: string,
  senderId: string
): Promise<boolean> => {
  try {
    // Create a properly formatted ISO timestamp string
    const now = new Date().toISOString();
    console.log(`[markMessagesAsRead] Marking messages as read from ${senderId} to ${receiverId} at ${now}`);
    
    // Make sure to include the timestamp in the update
    const { error, data } = await supabase
      .from('messages')
      .update({ read_at: now })
      .eq('receiver_id', receiverId)
      .eq('sender_id', senderId)
      .is('read_at', null)
      .select();
      
    if (error) {
      console.error('[markMessagesAsRead] Failed to mark messages as read:', error);
      return false;
    }
    
    console.log(`[markMessagesAsRead] Successfully marked ${data?.length || 0} messages as read at ${now}`);
    return true;
  } catch (err) {
    console.error('[markMessagesAsRead] Exception:', err);
    return false;
  }
};

// Helper function to mark a single message as read - Fixed to ensure read_at is properly set
export const markMessageAsRead = async (messageId: string): Promise<boolean> => {
  try {
    // Create a properly formatted ISO timestamp string
    const now = new Date().toISOString();
    console.log(`[markMessageAsRead] Marking message ${messageId} as read at ${now}`);
    
    // Make sure to include the timestamp in the update and return the updated record
    const { error, data } = await supabase
      .from('messages')
      .update({ read_at: now })
      .eq('id', messageId)
      .is('read_at', null)
      .select();
      
    if (error) {
      console.error('[markMessageAsRead] Failed to mark message as read:', error);
      return false;
    }
    
    const wasUpdated = data && data.length > 0;
    console.log(`[markMessageAsRead] ${wasUpdated ? 'Successfully marked' : 'No need to mark'} message ${messageId} as read at ${now}`);
    return wasUpdated;
  } catch (err) {
    console.error('[markMessageAsRead] Exception:', err);
    return false;
  }
};
